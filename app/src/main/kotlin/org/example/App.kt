/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.example

import com.lordcodes.turtle.shellRun
import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.Node
import org.w3c.dom.NodeList
import java.net.URL
import java.time.LocalDate
import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory


// Making this a URL has no real advantages besides being more explicit about what they are
val CATECHISM_URL:URL =URL("https://feeds.fireside.fm/catechisminayear/rss")
val BIBLE_URL:URL =URL( "https://feeds.fireside.fm/bibleinayear/rss")

fun main() {
    mainloop@ while (true) {
         // Prompt until valid input for which podcast to play
        var selectedURL: URL? = null
        while (selectedURL == null) {
            print("Would you like to listen to the [B]ible in a Year or the [C]atechism in Year (q to quit):")
            val bibleOrCatechism = readlnOrNull() ?: continue
            if (listOf("b", "bible", "bible in a year", "biy").contains(bibleOrCatechism.lowercase())) {
                selectedURL = BIBLE_URL
            } else if (listOf("c", "catechism", "catechism in a year", "ciy").contains(bibleOrCatechism.lowercase())){
                selectedURL = CATECHISM_URL
            } else if (listOf("q", "quit", "exit").contains(bibleOrCatechism.lowercase())){
                // The user wants to quit, break the outer loop
                break@mainloop
            } else {
                println("Invalid input")
            }
        }

        println("Loading episodes")

        // Parse the XML from the podcast url
        val builderFactory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()
        val docBuilder: DocumentBuilder = builderFactory.newDocumentBuilder()
        val doc: Document = docBuilder.parse(selectedURL.toString())
        doc.documentElement.normalize()

        // Each "item" is an episode of the podcast
        val items: NodeList = doc.documentElement.getElementsByTagName("item")

        // Create empty list of episodes
        val episodes = mutableListOf<Episode>()

        // Starting value of while loop iterator
        // Go backwards since the oldest episode is at the bottom of the xml file
        var episodeIndex = items.length - 1

        // Go until we have the full year of episodes
        while (episodes.size <= 365) {
            // Get the episode
            val episode: Node = items.item(episodeIndex)
            // Convert it to an element
            val episodeElement = episode as Element
            // See if it's a Day N episode
            if (isDay(episodeElement)) {
                // Add it to the list if so
                episodes.add(episodeFromElement(episodeElement))
            }
            episodeIndex--
        }



        var requestedEpisodeIndex = -1

        // Prompt until valid episode is requested
        while (requestedEpisodeIndex < 0) {
            // Include current day of year in prompt
            val today = LocalDate.now()
            val doy = today.dayOfYear
            val year = today.year
            println("Which day do you want to listen to? (Today is day $doy of $year)")
            val input = readln()
            val inputInt = input.toIntOrNull()
            if (inputInt == null){
                println("Must be a number")
                continue
            }

            // No, I'm not taking leap-years into account.
            // There are only 365 episodes
            if (inputInt in 1..365) {
                requestedEpisodeIndex = inputInt
            } else {
                println("Invalid input, episode must be between 1 and 365")
            }
        }

        // Get episode from list of episodes
        val requestedEpisode = episodes[requestedEpisodeIndex - 1]
        // Print out name
        println("Playing ${requestedEpisode.title}")
        // Play in mpv
        shellRun("mpv", listOf(requestedEpisode.url.toString()))
        println("Done playing ${requestedEpisode.title}")
    }
}

/**
 * Whether it's an actual day of BIY/CIY or a bonus episode
 */
fun isDay(element: Element): Boolean{
  return element.getElementsByTagName("title").item(0).textContent.contains("Day ")
}

/**
 * Create an Episode from an XML element
 */
fun episodeFromElement(element: Element): Episode{
        val episodeFullTitle = (element.getElementsByTagName("title").item(0) as Element).textContent
        val episodeTitleWithoutYear = " \\(\\d{4}\\)".toRegex().replace(episodeFullTitle, "")
        val episodeTitle = episodeTitleWithoutYear.split(": ")[1]
        val episodeURL = (element.getElementsByTagName("enclosure").item(0) as Element).getAttribute("url")
        return Episode(episodeTitle, URL(episodeURL))
}

/**
 * Basic data about podcast episodes
 */
data class Episode(
    val title: String,
    val url: URL
)
